// Code generated by soft.generator.ts. DO NOT EDIT.

// *****************************************************************************
// Copyright(c) 2024 MASA Group                                                 
//                                                                              
// This Source Code Form is subject to the terms of the Mozilla Public          
// License, v. 2.0. If a copy of the MPL was not distributed with this          
// file, You can obtain one at https://mozilla.org/MPL/2.0/.                    
//                                                                              
// *****************************************************************************


import * as deepEqual from "deep-equal";
import { anything , capture, instance, mock, reset, verify, when } from "ts-mockito";
import {
    EAdapter,
    EAnnotation,
    EList,
    EModelElementImpl,
    ENotificationChain,
    ENotifyingList,
    EOPPOSITE_FEATURE_BASE,
    EObject,
    EObjectInternal,
    EObjectList,
    EResource,
    EResourceSet,
    EcoreConstants,
    ImmutableEList,
    URI,
    getEcorePackage,
    isEObjectList,
} from "./internal"


interface EAnnotationInternal extends EAnnotation, EObjectInternal {} 

describe("EModelElementImpl", () => {
	
	test("eStaticClass", () => {
        let o = new EModelElementImpl()
		expect(o.eStaticClass()).toBe(getEcorePackage().getEModelElement())
    });

	
	test("getEAnnotations", () => {
		let o = new EModelElementImpl()
		expect(o.eAnnotations).not.toBeNull()
	})
	
	test("getEAnnotation", () => {
		let o = new(EModelElementImpl)
		expect(() => o.getEAnnotation("")).toThrow(Error)
	})
	
	
	
	test("eGetFromID", () => {
		let o = new EModelElementImpl()
		expect(() => o.eGetFromID(-1,true)).toThrow(Error)
		expect(o.eGetFromID(EcoreConstants.EMODEL_ELEMENT__EANNOTATIONS,true)).toStrictEqual(o.eAnnotations)
		expect(
			deepEqual(
				o.eGetFromID(EcoreConstants.EMODEL_ELEMENT__EANNOTATIONS,false),
				(o.eAnnotations as EObjectList<EAnnotation>).getUnResolvedList()
			)
		).toBeTruthy()
	})
	
	test("eSetFromID", () => {
		let o = new EModelElementImpl()
		expect(() => o.eSetFromID(-1,null)).toThrow(Error)
		{
			// list with a value
			let mockValue = mock<EAnnotationInternal>()
			let value = instance(mockValue)
			let l = new ImmutableEList<EAnnotation>([value])
			when(mockValue.eInverseAdd(o,EcoreConstants.EANNOTATION__EMODEL_ELEMENT,anything())).thenReturn(null) 
			
			// set list with new contents
			o.eSetFromID(EcoreConstants.EMODEL_ELEMENT__EANNOTATIONS, l)
			// checks
			expect(o.eAnnotations.size()).toBe(1)
			expect(o.eAnnotations.get(0)).toBe(value)
			verify(mockValue.eInverseAdd(o,EcoreConstants.EANNOTATION__EMODEL_ELEMENT,anything())).once()
			
		}
		
		
	})
	
	test("eIsSetFromID", () => {
		let o = new EModelElementImpl()
		expect(() => o.eIsSetFromID(-1)).toThrow(Error)
			expect(o.eIsSetFromID(EcoreConstants.EMODEL_ELEMENT__EANNOTATIONS)).toBeFalsy()
	})
	
	test("eUnsetFromID", () => {
		let o = new EModelElementImpl()
		expect(() => o.eUnsetFromID(-1)).toThrow(Error)
		{
			o.eUnsetFromID(EcoreConstants.EMODEL_ELEMENT__EANNOTATIONS)
			let v = o.eGetFromID(EcoreConstants.EMODEL_ELEMENT__EANNOTATIONS, false)
			expect(v).not.toBeNull()
			let l = v as EList<EAnnotation> 
			expect(l.isEmpty()).toBeTruthy()
		}
	})
	
	test("eInvokeFromID", () => {
		let o = new EModelElementImpl()
		expect(() => o.eInvokeFromID(-1,null)).toThrow(Error)
		expect(() => o.eInvokeFromID(EcoreConstants.EMODEL_ELEMENT__GET_EANNOTATION_ESTRING,null)).toThrow(Error)
	})
	
	test("eBasicInverseAdd", () => {
		let o = new EModelElementImpl()
		{
			let mockObject = mock<EObject>()
			let object = instance(mockObject)
			let mockNotifications = mock<ENotificationChain>() 
			let notifications = instance(mockNotifications)
			expect(o.eBasicInverseAdd(object,-1,notifications)).toBe(notifications)
		}
		{
			let mockValue = mock<EAnnotationInternal>()
			let value = instance(mockValue)
			o.eBasicInverseAdd(value,EcoreConstants.EMODEL_ELEMENT__EANNOTATIONS,null)
			expect(o.eAnnotations.contains(value)).toBeTruthy()
		}
		
	})
	
	test("eBasicInverseRemove", () => {
		let o = new EModelElementImpl()
		{
			let mockObject = mock<EObject>()
			let object = instance(mockObject)
			let mockNotifications = mock<ENotificationChain>() 
			let notifications = instance(mockNotifications)
			expect(o.eBasicInverseRemove(object,-1,notifications)).toBe(notifications)
		}
		{
			// initialize list with a mock object
			let mockValue = mock<EAnnotationInternal>()
			let value = instance(mockValue)
			when(mockValue.eInverseAdd(o,EcoreConstants.EANNOTATION__EMODEL_ELEMENT,anything())).thenReturn(null) 
			
			o.eAnnotations.add(value)
		
			// basic inverse remove
			o.eBasicInverseRemove(value,EcoreConstants.EMODEL_ELEMENT__EANNOTATIONS,null)
		
			// check it was removed
			expect(o.eAnnotations.contains(value)).toBeFalsy()
		}
		
	})
	

})

